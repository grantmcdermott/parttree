% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/geom_parttree.R
\name{geom_parttree}
\alias{geom_parttree}
\title{Visualise tree partitions}
\usage{
geom_parttree(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  linejoin = "mitre",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  flipaxes = FALSE,
  ...
)
}
\arguments{
\item{mapping}{Set of aesthetic mappings created by \code{\link[ggplot2:aes]{aes()}}. If specified and
\code{inherit.aes = TRUE} (the default), it is combined with the default mapping
at the top level of the plot. You must supply \code{mapping} if there is no plot
mapping.}

\item{data}{An \link[rpart:rpart.object]{rpart::rpart.object} or an object of compatible
type (e.g. a decision tree constructed via the \code{partykit}, \code{tidymodels}, or
\code{mlr3} front-ends).}

\item{stat}{The statistical transformation to use on the data for this
layer, either as a \code{ggproto} \code{Geom} subclass or as a string naming the
stat stripped of the \code{stat_} prefix (e.g. \code{"count"} rather than
\code{"stat_count"})}

\item{position}{Position adjustment, either as a string naming the adjustment
(e.g. \code{"jitter"} to use \code{position_jitter}), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.}

\item{linejoin}{Line join style (round, mitre, bevel).}

\item{na.rm}{If \code{FALSE}, the default, missing values are removed with
a warning. If \code{TRUE}, missing values are silently removed.}

\item{show.legend}{logical. Should this layer be included in the legends?
\code{NA}, the default, includes if any aesthetics are mapped.
\code{FALSE} never includes, and \code{TRUE} always includes.
It can also be a named logical vector to finely select the aesthetics to
display.}

\item{inherit.aes}{If \code{FALSE}, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. \code{\link[ggplot2:borders]{borders()}}.}

\item{flipaxes}{Logical. By default, the "x" and "y" axes variables for
plotting are determined by the first split in the tree. This can cause
plot orientation mismatches depending on how users specify the other layers
of their plot. Setting to \code{TRUE} will flip the "x" and "y" variables for
the \code{geom_parttree} layer.}

\item{...}{Other arguments passed on to \code{\link[ggplot2:layer]{layer()}}. These are
often aesthetics, used to set an aesthetic to a fixed value, like
\code{colour = "red"} or \code{size = 3}. They may also be parameters
to the paired geom/stat.}
}
\description{
\code{geom_parttree()} is a simple extension of
\code{\link[ggplot2:geom_tile]{ggplot2::geom_rect()}}that first calls
\code{\link[=parttree]{parttree()}} to convert the inputted tree object into an
amenable data frame.
}
\details{
Because of the way that \code{ggplot2} validates inputs and assembles
plot layers, note that the data input for \code{geom_parttree()} (i.e. decision
tree object) must assigned in the layer itself; not in the initialising
\code{\link[ggplot2:ggplot]{ggplot2::ggplot()}} call. See Examples.
}
\section{Aesthetics}{

\code{geom_parttree()} aims to "work-out-of-the-box" with minimal input from
the user's side, apart from specifying the data object. This includes taking
care of the data transformation in a way that, generally, produces optimal
corner coordinates for each partition (i.e. \code{xmin}, \code{xmax}, \code{ymin}, and
\code{ymax}). However, it also understands the following aesthetics that users
may choose to specify manually:
\itemize{
\item{\code{fill} (particularly encouraged, since this will provide a visual
cue regarding the prediction in each partition region)}
\item{\code{colour}}
\item{\code{alpha}}
\item{\code{linetype}}
\item{\code{size}}
}
}

\examples{
library(rpart)

### Simple decision tree (max of two predictor variables)

iris_tree = rpart(Species ~ Petal.Length + Petal.Width, data=iris)

## Plot with original iris data only
p = ggplot(data = iris, aes(x = Petal.Length, y = Petal.Width)) +
  geom_point(aes(col = Species))

## Add tree partitions to the plot (borders only)
p + geom_parttree(data = iris_tree)

## Better to use fill and highlight predictions
p + geom_parttree(data = iris_tree, aes(fill = Species), alpha=0.1)

## To drop the black border lines (i.e. fill only)
p + geom_parttree(data = iris_tree, aes(fill = Species), col = NA, alpha = 0.1)


### Example with plot orientation mismatch

p2 = ggplot(iris, aes(x=Petal.Width, y=Petal.Length)) +
  geom_point(aes(col=Species))

## Oops
p2 + geom_parttree(data = iris_tree, aes(fill=Species), alpha = 0.1)

## Fix with 'flipaxes = TRUE'
p2 + geom_parttree(data = iris_tree, aes(fill=Species), alpha = 0.1, flipaxes = TRUE)


### Various front-end frameworks are also supported, e.g.:

library(parsnip)

iris_tree_parsnip =
  decision_tree() \%>\%
  set_engine("rpart") \%>\%
  set_mode("classification") \%>\%
  fit(Species ~ Petal.Length + Petal.Width, data=iris)

p + geom_parttree(data = iris_tree_parsnip, aes(fill=Species), alpha = 0.1)


### Trees with continuous independent variables are also supported. But you
### may need to adjust (or switch off) the fill legend to match the original
### data, e.g.:

iris_tree_cont = rpart(Petal.Length ~ Sepal.Length + Petal.Width, data=iris)
p3 = ggplot(data = iris, aes(x = Petal.Width, y = Sepal.Length)) +
 geom_parttree(
   data = iris_tree_cont,
   aes(fill = Petal.Length), alpha=0.5
   ) +
  geom_point(aes(col = Petal.Length)) +
  theme_minimal()

## Legend scales don't quite match here:
p3

## Better to scale fill to the original data
p3 + scale_fill_continuous(limits = range(iris$Petal.Length))
}
\seealso{
\code{\link[=parttree]{parttree()}}, \code{\link[ggplot2:geom_tile]{ggplot2::geom_rect()}}.
}
